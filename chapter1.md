# RSA

RSA密鑰一般是1024位或2048位，位指的是二進位數

第一步:隨便找兩個質數a b

```
這裡假設a,b是23和29
```

第二步:計算φ\(axb\)

```
23x29 = 667  
φ(667)根據歐拉定理得到為(23-1)*(29-1) = 616
```

第三步: 隨便找一個數字e，使得1&lt; e &lt; φ\(axb\)的數字，且e与φ\(axb\)互質

```
這裡選19
```

第四步: 找到一個數字d，使得 ed ≡ 1 \(mod φ\(n\)\)

```
//以上面為例子
function te() {
  let X = 0
  while((19*X) % 616 !== 1) {
     X++;
   }
   return X
 }

 //回傳227
```

第五步: 剛才找出n = 667,  e = 19 , d = 227

得到公鑰為\(667, 19\)  私鑰為\(667, 227\)

> 如果n可以被輕易被因數分解，d就可以算出，而私鑰將被破解

#### \# 加密

假設字串是ABC，使用**ASCII 為65,66,67 把他填充為四位數，並相連接**

```
006500660067
```

這時加密的公鑰匙為\(667, 19\) 所以加密方式為

```
(6500660067 的 19 次方) % 667
```

> 這裡因為數字是Big int所以算的時候不可直接用...\*\*...% ...，需要用相關Big INT模組不然會產生計算錯誤

得到數字為260

#### \# 解密

私鑰匙是\(667, 227\)

現在要把剛才的數字 148 解密

```
(148**227) % 667
```

這裡牽涉到BIg integer時常會出現infinity

需要使用Big-integer module

    var bigInt = require("big-integer");
    let msg = 27;
    let a = bigInt(msg).pow(19).mod(667);
    let b = bigInt(a).pow(227).mod(667);

    console.log(`輸入密文為:${msg}`)
    console.log(`密鑰為(667, 227)`)
    console.log(`輸入密文為:${b}`)

> 上面如果msg輸入數字過大也會產生解密後和輸入數字不同之情況
>
> 建議將密文以單字為單位轉為ascII然後個別存入陣列轉換



